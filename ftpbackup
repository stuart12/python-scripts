#!/usr/bin/python
# ftpbackup,  backup filesystems to dl.free.fr, Copyright (C) 2012 Stuart Pook
#This program is free software: you can redistribute it and/or modify it under
#the terms of the GNU General Public License as published by the Free Software
#Foundation, either version 3 of the License, or (at your option) any later version.
#This program is distributed in the hope that it will be useful, but WITHOUT ANY
#WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
#FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import with_statement
import os
import os.path
import sys
import tempfile
import getopt
import subprocess
import hashlib
import datetime
import shutil
import ftplib
import time

gpg_options = ('gpg', '--options', '/dev/null', "--always-trust")
#gpg_options = ('gpg', '--no-permission-warning', '--options', '/dev/null', '--homedir', '/home/stuart/.gnupg')

myname = os.path.basename(sys.argv[0])
verbose = False
ftp = True
options = [ "noftp", "verbose", ]
def usage():
	sys.exit("usage: " + myname + " " + str(options))
try:
	opts, args = getopt.getopt(sys.argv[1:], "nv", options)
except getopt.GetoptError:
	usage()
for o, a in opts:
	if o in ("--noftp",  "-n"):
		ftp = False
	elif o in ("--verbose",  "-v"):
		verbose = True
	else:
		usage()

devnull = open("/dev/null", "r+")
gpg_options = gpg_options + ('-z', '9', '--encrypt', '--recipient')

def label():
	random = open("/dev/urandom")
	r = ord(random.read(1))
	label = chr((r & 0xf) + ord('a'))
	for i in range(0, (r >> 4) % 8):
		r = ord(random.read(1))
		label += chr((r & 0xf) + ord('A'))
		label += chr((r >> 4) + ord('a'))
	random.close()
	return label

def check(message):
	if message != None:
		sys.exit(message)

def getoutput(args):
	err = tempfile.TemporaryFile()
	out = tempfile.TemporaryFile()
	status = subprocess.Popen(args, stdin=devnull, stdout=out, stderr=err, close_fds=True).wait()
	if status != 0:
		err.seek(0)
		r = (str(args) + " failed " + str(status) + ": " + err.read())
		check(r)
	err.close()
	out.seek(0)
	return out

def run(args):
	run_input(args, devnull)

def run_input(args, input):
	if verbose:
		print args
	err = tempfile.TemporaryFile()
	status = subprocess.Popen(args, stdin=input, stdout=err, stderr=subprocess.STDOUT, close_fds=True).wait()
	if status != 0:
		err.seek(0)
		r = (str(args) + " failed " + str(status) + ": " + err.read())
		check(r)
	err.close()
	
def make_dump_command(device):
	return ('dump', "-0", '-L', label(), '-f', '-', '-I', '1', '-q', device)

class Waiter:
	def __init__(self,  gpg,  device):
		self.dump_stderr = tempfile.TemporaryFile()
		self.dump_command = make_dump_command(device)
		if verbose: print gpg
		self.crypter = subprocess.Popen(gpg, close_fds = True, stdin = subprocess.PIPE, stdout = subprocess.PIPE)
		self.pid = os.fork()
		if self.pid != 0:
			self.crypter.stdin.close()
	def is_child(self):
		return self.pid == 0;
	def dump(self):
		self.child("dump")
		if verbose: print self.dump_command 
		self.dumper = subprocess.Popen(self.dump_command, close_fds = True, stdout = self.crypter.stdin, stderr = self.dump_stderr)
		self.crypter.stdin.close()
		self.dumper.wait()
		if verbose: print "dump done",  self.dumper.returncode
	def child_exit(self):
		self.child("child_exit")
		os._exit(self.dumper.returncode)
	def ftp_done(self):
		self.parent("ftp_done")
		p,  child_status = os.waitpid(self.pid,  0)
		self.dump_stderr.seek(0) 
		if child_status != 0:
			check(str(self.dump_command) +  " failed " + str(child_status) + self.dump_stderr.read())
		self.crypter.wait()
		if self.crypter.returncode != 0:
			check((myname + ": gpg of %s failed: %d" % (fs, self.crypter.returncode)))
		self.dump_stderr.close()
	def crypt_output(self):
		self.parent("crypt_output")
		return self.crypter.stdout
	def parent(self,  what):
		if self.pid == 0: print >> sys.stderr,  "should only call " + what + " in parent"
	def child(self,  what):
		if self.pid != 0: print >> sys.stderr,  "should only call " + what + " in child"
		
def snapshot_dump(device, keyfile, gpg):
	fs = os.path.basename(device)
	unlocked_tag = fs + "_backup_unlocked"
	unlocked = os.path.join("/dev", "mapper", unlocked_tag)
	snapshot_tag = fs + "_backup_snapshot"
	snapshot = os.path.join(os.path.dirname(device), snapshot_tag)
	if os.path.exists(unlocked):
		run(["cryptsetup", "luksClose", unlocked_tag])
	if os.path.exists(snapshot):
		run(["lvremove", "--force", snapshot])
	job = Waiter(gpg,  unlocked)
	if job.is_child():
		run(["lvcreate", "--size", "128M", "--snapshot", "--name", snapshot_tag, device])
		try:
			if keyfile[0] == '!':
				key = getoutput(["/bin/sh", "-c", keyfile[1:]])
				run_input(["cryptsetup", "luksOpen", snapshot, unlocked_tag, "--non-exclusive", "--readonly", "--key-file=-"], key)
				key.close()
			else:
				run(["cryptsetup", "luksOpen", snapshot, unlocked_tag, "--non-exclusive", "--readonly", "--key-file", keyfile])
			try:
				job.dump()
			finally:
				run(["cryptsetup", "luksClose", unlocked_tag])
		finally:
			time.sleep(1) # to avoid both finally commands being run at the same time when interrupted
			run(["lvremove", "--force", snapshot])
		job.child_exit()
	return job

def read_mtab(fs):
	mtab = "/etc/mtab"
	fs_fake_special = None
	for line in open(mtab):
		dev, mount_point, type, flags, d0, d1 = line.split()
		if mount_point == fs:
			fs_fake_special = dev
	if fs_fake_special == None:
		sys.exit(fs + " not found in " + mtab)

	mounts = "/proc/mounts"
	fs_real_special = None
	for line in open(mounts):
		dev, mount_point, type, flags, d0, d1 = line.split()
		if mount_point == fs:
			fs_real_special = dev
	if fs_real_special == None:
		sys.exit(fs + " not found in " + mounts)
	return fs_real_special, fs_fake_special

def remount(fs, special, flag):
	run(['mount', '-o', 'remount,' + flag, special, fs])

def remount_dump(fs, gpg):
	fs_real_special, fs_fake_special = read_mtab(fs)
	remount(fs, fs_fake_special, "ro")
	job = Waiter(gpg,  fs_real_special)
	if job.is_child():
		try:
			job.dump()
		finally:
			remount(fs, fs_fake_special, "rw")
		job.child_exit()
	return job

class MD5:
 	def digest(self):
		return self.dumpmd5.hexdigest()
	def __init__(self,  verbose):
 		self.dumpmd5 = hashlib.md5()
		self.bytes = 0
		self.verbose = verbose
	def __call__(self, buf):
		self.dumpmd5.update(buf)
		self.bytes += len(buf)
		if self.verbose:
			print "just wrote",  len(buf),  "bytes, total",  "%.0f KiB    \r" % (self.bytes / 1024), 
			sys.stdout.flush()
	def size(self):
		return self.bytes

def skip(file,  md5):
	while True:
		b = file.read(8192)
		if b == "":
			break
		md5(b)
		
def find_eol(response,  start):
	end0 = response.find('\n',  start)
	end1 = response.find('\r',  start)
	if end0 == -1:
		return end1
	if end1 == -1:
		return end0
	if end1 < end0:
		return end1
	return end0

def get_url_from_response(remote_file,  response):
	success = response.find('226-Fichier "' +remote_file +'" uploade avec succes.')
	if  success == -1:
		check(remote_file + " not uploaded correctly in \n" + response)
	root = "http://dl.free.fr/";
	leadin = '226-Il est disponible via '
	start = response.find(leadin + root,  success)
	if start == -1:
		check("could not find the start of the url for " + remote_file)
	end = find_eol(response,  start)
	if end == -1:
		check("could not find the end of the url for " + remote_file)
	if end == start:
		check("curl for " + remote_file + " is empty")
	return response[start + len(leadin): end]
	
dummy_reponse0 = """226-Fichier transfere sans probleme
226-Traitements en cours....
226-
226-Fichier \""""
	
dummy_reponse1 = """\" uploade avec succes.
226-Il est disponible via http://dl.free.fr/test-url
226-
226 Vous pouvez a tout moment supprimer ce fichier via: http://dl.free.fr/rm.pl?h=test-url&i=25546302&s=L9ZXaFeTKLPKR7eB9Ygq2OJG4uqSBiow"""

for a in args:
	cfg = open(a)
	gpgkey = cfg.readline().rstrip()
	gpg = gpg_options + (gpgkey,  )
	logname = cfg.readline().rstrip()
	if ftp:
		log = open(logname, "a")
	ftphost, ftpuser, ftppasswd = cfg.readline().split()
	if verbose:
		print "gpgkey=", gpgkey, "logname=", logname, "ftphost=", ftphost, "ftpuser=", ftpuser, "ftppasswd=", ftppasswd
	tries = 0
	while ftp:
		try:
			ftpconnection = ftplib.FTP(ftphost, ftpuser, ftppasswd)             
		except EOFError, e:
			if verbose: print "EOFError", e
		else:
			if verbose: print "connection to", ftphost, "open after " + str(tries) + " failures"
			break
		tries = tries + 1
		if tries > 60:
			sys.exit(str(tries) + " connections to " + ftphost + " failed")
		time.sleep(20)
	else:
		ftpconnection = None
	for l in cfg:
		if l[0] == '#':
			continue
		md5 = MD5(verbose)
		# dow type device key
		dow,  type,  device, key = l.rstrip().split(None, 3)
		if type == "remount":
			if verbose:
				print "remount_dump of", "device=", device
			job = remount_dump(device, gpg)
		elif type == "crypt":
			if verbose:
				print "snapshot_dump of", "device=", device, "key=", key
			job = snapshot_dump(device, key, gpg)
		else:
			print  >> sys.stderr,  "bad type",  type
		fs = os.path.basename(device).split('-')[-1]
		name = fs + datetime.datetime.now().strftime("-%F")
		start = time.time()
		if ftp:
			r = ftpconnection.storbinary("STOR " + name, job.crypt_output(),  8192,  md5)
 		else:
			skip(job.crypt_output(),  md5)
			r = dummy_reponse0 + name + dummy_reponse1
		url = get_url_from_response(name,  r)
		seconds = time.time() - start
		timestamp = datetime.datetime.fromtimestamp(start).strftime("%Y-%m-%d %H:%M:%S")
		message = "%s %s %s %s %d bytes %.0f MiB %.0fs %.0f kbit/s %.0f minutes" % (timestamp, name, url,  md5.digest(), md5.size(),  md5.size() / 1024 / 1024,  seconds, md5.size() * 8 / seconds / 1024.0,  seconds / 60)
		if ftp:
			log.write(message + "\n")
		if verbose:
			print "\n",  message
		job.ftp_done()
		if verbose: print device,  "done"
		
	if ftp:
		ftpconnection.quit()
	cfg.close()
