#!/usr/bin/python3
# transform Copyright (c) 2013 Stuart Pook (http://www.pook.it/)
# backup btrfs filesystems on a btrfs filesystem
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# http://www.sanitarium.net/golug/rsync+btrfs_backups_2011.html
# https://github.com/oxplot/rsyncbtrfs

# ? --no-whole-file

import datetime
import optparse
import os
import sys

def get_filesystem_type(path, options):
	device_no = os.stat(path).st_dev
	with open("/proc/mounts") as mounts:
		for mount in mounts:
			fields = mount.split()
			if len(fields) > 2:
				if os.stat(fields[1]).st_dev == device_no:
					return fields[2]

#	tag = datetime.datetime.now(pytz.utc).isoformat()

#sudo btrfs subvolume snapshot -r /disks/music /tmp/stuart2Tb/snapshots/music/2013-03-04T00:33:24.009229+00:00
#Create a readonly snapshot of '/disks/music' in '/tmp/stuart2Tb/snapshots/music/2013-03-04T00:33:24.009229+00:00'
#:; sudo btrfs subvolume snapshot -r /disks/photos /tmp/stuart2Tb/snapshots/photos/2013-03-04T00:34:43.633462+00:00

def call(cmd, options):
	print(" ".join(cmd))
	
def snapshot(fs, snapshot, options):
	call(["btrfs", "subvolume", "snapshot", "-r", fs, snapshot ], options)

def btrfs_backup(fs, options):
	tag = datetime.datetime.utcnow().isoformat()
	disk = os.path.join("/disks/", fs)
	snapshot = os.path.join(options.snapshots, fs, tag)
	if get_filesystem_type(fs, options) == "btrfs":
		snapshot(disk, snapshot, options)
		source = snapshot
	else:
		source = disk
	call(["rsync", ] + options.rsync + [ source, os.path.join(options.backups, fs, "current") ], options)
	snapshot(os.path.join(options.backups, fs, "current"), os.path.join(options.backups, fs, tag), options)
	
def backup(source, snapshot, destination):
	
def read_config(config_file, options):
	with open(config_file) as config:
		for line in config:
			args = line.split()
			if len(args) == 3:
				backup(args[0], args[1], args[2])
			else:
				backup(args[0], None, args[1])

def main():	
	parser = optparse.OptionParser(usage="%prog [--help] [options] filesystem ...")
	parser.disable_interspersed_args()
	
	rsync_opts = ["--archive", "--one-file-system", "--hard-links", "--inplace", "--delete" ]
	parser.add_option("-v", "--verbose", action="store_true", help="verbose")
	parser.add_option("-n", "--dryrun", action="store_true", help="do not execute")
	parser.add_option("--snapshots", default="/tmp/stuart2Tb/snapshots", help="parent directory where to create snapshots")
	parser.add_option("--backups", default="/data/snapshot_backups", help="parent directory where to rsync")
	parser.add_option("--rsync", default=rsync_opts, action="append", help="extras rsync option")
	
	(options, args) = parser.parse_args()
	
	if len(args) == 0:
		parser.error("at least one filesystem")
		
	for fs in args:
		btrfs_backup(fs, options)

if __name__ == '__main__':
	main()
