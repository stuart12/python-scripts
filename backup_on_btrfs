#!/usr/bin/python3
# transform Copyright (c) 2013 Stuart Pook (http://www.pook.it/)
# backup btrfs filesystems on a btrfs filesystem
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# http://www.sanitarium.net/golug/rsync+btrfs_backups_2011.html
# https://github.com/oxplot/rsyncbtrfs

# ? --no-whole-file

import datetime
import optparse
import os
import subprocess

def call(cmd, options):
	if options.verbose or options.dryrun:
		print(" ".join(cmd))
	if not options.dryrun:
		subprocess.check_call(cmd)

def mkdir(dir, options):
	mode = 0o700
	if options.verbose or options.dryrun:
		print("mkdir -m %o %s" % (mode, dir))
	if not options.dryrun:
		os.mkdir(dir, mode)

#	tag = datetime.datetime.now(pytz.utc).isoformat()

#sudo btrfs subvolume snapshot -r /disks/music /tmp/stuart2Tb/snapshots/music/2013-03-04T00:33:24.009229+00:00
#Create a readonly snapshot of '/disks/music' in '/tmp/stuart2Tb/snapshots/music/2013-03-04T00:33:24.009229+00:00'
#:; sudo btrfs subvolume snapshot -r /disks/photos /tmp/stuart2Tb/snapshots/photos/2013-03-04T00:34:43.633462+00:00

def btrfs(subcommand, options):
	call(["btrfs"] + subcommand, options)

def subvolume(volname, options):
	btrfs(["subvolume", "create"]  + [volname], options)
	
def first(options):
	subvolume(options.backups, options)
	
def initialise(fs, options):
	top = os.path.join(options.backups, fs)
	subvolume(os.path.join(options.backups, top), options)
	secret = os.path.join(top, options.secret)
	mkdir(secret, options)
	subvolume(os.path.join(secret, options.current), options)
	
def snapshot(fs, snapshot, options):
	call(["btrfs", "subvolume", "snapshot", "-r", fs, snapshot ], options)

def btrfs_backup(fs, options):
	tag = datetime.datetime.utcnow().isoformat() + "+00:00"
	destination = os.path.join(options.snapshots, fs, tag)
	snapshot(os.path.join(options.data, fs), destination, options)
	call(["rsync", ] + options.rsync +[ destination + "/", os.path.join(options.backups, fs, options.secret, options.current) ], options)
	snapshot(os.path.join(options.backups, fs, options.secret, options.current), os.path.join(options.backups, fs, tag), options)

def main():	
	parser = optparse.OptionParser(usage="%prog [--help] [options] filesystem ...")
	parser.disable_interspersed_args()
	
	rsync_opts = ["--archive", "--one-file-system", "--hard-links", "--inplace", "--delete" ]
	parser.add_option("--first", action="store_true", help="make backup directory volume structure")
	parser.add_option("--initialise", action="store_true", help="make backup directory volume structure for new filesystem")
	parser.add_option("-v", "--verbose", action="store_true", help="verbose")
	parser.add_option("-n", "--dryrun", default=False, action="store_true", help="do not execute")
	parser.add_option("--data", default="/disks", help="volume to snapshot and backup [%default]")
	parser.add_option("--snapshots", default="/disks/snapshots", help="parent directory where to create snapshots [%default]")
	parser.add_option("--backups", default="/disks/backups/snapshot_rsync", help="parent directory where to rsync [%default]")
	parser.add_option("--rsync", default=rsync_opts, action="append", help="extras rsync option [%default]")
	parser.add_option("--secret", default="secret", help="directory to limit access to current [%default]")
	parser.add_option("--current", default="current", help="rsync target (subdirectory of secret) [%default]")
	
	(options, args) = parser.parse_args()
	
	if options.initialise and len(args) == 0:
		parser.error("at least one filesystem")
	
	if options.first:
		first(options)
	elif len(args) == 0:
		parser.error("at least one filesystem")
		
	for fs in args:
		if options.initialise:
			initialise(fs, options)
		btrfs_backup(fs, options)

if __name__ == '__main__':
	main()
